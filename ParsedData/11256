HW4: Homography mosaics 
     Due Nov 20 in EEE DropBox at 11:59 pm 
    

HW4: Homography mosaics


  

Mosaic of 4 images aligned with homographies




In this assignment, again prepared by the fearless  David Martin, you extend the field of view of a camera by forming a mosaic from multiple photographs. 

When images are taken with same optical center, they can be aligned with a homography transformation. To estimate the homography, you'll need 4 pairs of corresponding points in the overlap region. You'll mark these points manually. We discussed in class some methods for finding them automatically.

The following directory contains the source images for alignment, along with skeleton code:

Downloads


Programming: [20 points]


The first image in each example provided is the central image.  It's
simplest to construct a mosaic from a central image and a set of
peripheral images, since we then need to find just one homography for
each peripheral image.  Use the cpselect and cpcorr

functions to manually select and refine at least 4 pairs of
corresponding points in each overlap region between the central and
peripheral images.  These points should be located on high contrast
corners.


Next, compute the homography using linear least squares for each set
of correspondences to provide the mapping from points in the central
images and points in the peripheral images.  You'll probably want 
to write two functions such as:


function [H] = computeHomography(x1,y1,x2,y2)
function [x2,y2] = applyHomography(H,x1,y1)



Note that the inverse mapping is given simply by inv(H).


Use the central image's coordinate system for the final mosaic.  You
need to figure out the min and max pixel coordinates when the peripheral
images are mapped into the central image's coordinate system.  Simply
apply your homographies to the peripheral images' corner points to find
the extent of the final mosaic.


Now generate a meshgrid of points to cover the mosaic, send
these points through each homography in turn, and use

interp2 to extract pixel values from the source images.  For
each input image, this produces an image the size of the final mosaic;
pixels that are outside the source image are set to NaN.


Finally, assemble the mosaic from the remapped source images.  Use
isnan(I) to get a mask for each one that tells you which pixels
are valid and which are invalid.  For Part I, you may simply take a
pixel from any valid image.

Writeup: [10 points]

 Show the resulting mosaic for one of the provided examples.  Show
also the remapped source images before they are blended into the final 
mosaic.


 Show two mosaics of your own creation, each with at least 3 
source images.  Show
also the remapped source images before they are blended into the final 
mosaic.



Matlab Tips

 Don't forget the hold on command if you want to 
plot one thing on top of another.

 Running cpselect is a pain.  Don't do it more than
once for any pair of images!  You can use the save and

load functions to save and restore variables from your
matlab workspace.

 Do no use the full size images.  Resize them down so that your
debugging goes fast.  For your final results, 25% size is sufficient.

 You can treat the central image as just another source image
by using eye(3) as its homography.

 Use 'linear' interpolation with interp2; 
it's fast and looks good.  Just make sure you don't use nearest neighbor
interpolation, which looks terrible and may be the default.




Extra-credit
    As detailed in the  guidelines, any project handed by 11:59 pm on the previous day (Nov 19th), will recieve 10% (3 points) extra credit.