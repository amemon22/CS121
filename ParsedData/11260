HW2: Texture Synthesis
     Due Oct 23 in EEE DropBox at 11:59 pm 
    

    In this assignment, originally prepared by Rob Fergus, you will implement the Efros and Leung Texture Synthesis Algorithm. The original paper, along with pseudocode for the algorithm, can be found here. The description is quite nice, and contains all the information needed to implement the algorithm.

The following directory contains two images. Your task for this assignment is to

 Fill in the hole in fill.png. The hole is defined as pixels that have intensity 0.
 Pad the image extend.png by 11 pixels on each side. It is currently 53x49 pixels, and you will need to add pixels until it is 75x71 pixels.



    downloads
    
 
    Programming [25 points]

    Write the following 4 functions (each in their own file) 
    with the following prototypes to perform each of the
    processing steps, such that the following code should do something
    sensible:
    
    
Image = im2single(imread('fill.pgm'));
WindowSize = 7;
Result = FillImage(Image,WindowSize); % 10 pts
...(within FillImage.m)....
indices = GetUnFilledNeighbors(Image); % 5 pts
[matches,errs] = FindMatches(Template,Image); %10 pts
      
    
	
[Result] = FillImage(Image,WindowSize);
% FillImage - takes an input a grayscale image, and fills in the
% 0-values using Efros-Leung
%
% Image: a grayscale image, with some missing pixels set to 0
% Windowsize: The size of the window used for synthesis
% Result: a grayscale image with all pixels filled-in
	  
	[10 points] This function does all of the work. It will call both  GetUnFilledNeighbors and FindMatches in its body. It will return the Image, where all zero-valued pixels have been filled with a "synthesized" pixel using Efros & Leung's texture synthesis algorithm. The content of the function follows the pseudocode linked above. 
 Loosely, it loops over the set of unknown pixels which are adjacent to known pixel values. For each unknown pixel in this set, it finds the set of all matching pixel neighborhoods from the original Image. It then randomly picks a matching neighbor to fill in the current unknown pixel.
	  

	
	
function [indices] = GetUnFilledNeighbors(Image); % 5 pts
% GetUnFilledNeighbors
% Image: grayscale image, with some missing pixels set to 0
% indices: The set of indices of unfilled-pixels which are neighbors with a filled pixel


	[5 points] This function looks for unfilled pixels which are next to at least one filled-in pixel. This can be computed efficiently using morphological dilate operation - see  here . Let mask be a binary image, where '1' denotes a filled-in pixel.  imdilate(mask,ones(3)) - mask  produces a binary image of unfilled pixels which are neighbors with a filled pixel. One can find the indices of the non-zero pixels using the  find  command. I suggest using  help  for more information on these functions.

	
function [match,err] = FindMatch(Template,Image)
% This function takes the patch Template, 
% and finds similar-looking patches from Image

% Image: grayscale image
% Template: small grayscale image (of size WindowSize by WindowSize)
%
%
% match: A vector of pixel values that match well with the center of Template
% err: A vector of errs for each pixel value
	  
	
	[10 points] This function searches Image for image patches that match well with Template. Note that template will always contain at least one unfilled pixel - the center. Use a Guassian-weighted sum-of-squared-difference (SSD) score to measure the match between the Template and a patch in the image. You can use  GaussMask = fspecial('gaussian',size,sigma) to create a Gaussian mask. Make sure that you don't use the unfilled pixels to score the match of the Template and a patch from the image.
	

    

    Matlab Tips
    
      ind2sub  is a handy command that generates the x,y location corresonding to an index. It will be useful to iterate over the list of indices returned by  GetUnFilledNeighbors .
	  rand  is the command for generating a random number. This will be useful for randomly selected a matching patch.
	 One can multiply all the entries of two matrics A and B with  A.*B. This may prove useful for calculating the Guassian-weighted SSD score.

	 Plot the image as you fill the pixels in, like a movie.  This will be useful for debugging, and also looks pretty cool! Use  imshow(Image); drawnow;  to plot the image and force Matlab to update the figure window. Place this command within the main loop of  FillImage.m to generate a sequence of images.
	 Debug your code using a small WindowSize, since this makes the algorithm faster.
    	

    Writeup [10 points]
    
    
      Use both images for the writeup.

    [5 points] Show the results on  expand.png , varying the windowsize parameter. Zoom in and show details illustrating the success/failures of the method.
    [5 points] Show the results on  fill.png , varying the windowsize parameter. Zoom in and show details illustrating the success/failures of the method.

    
    Extra-credit
    As detailed in the guidelines  guidelines, any project handed by 11:59 pm on the previous day, will recieve 10% extra credit.